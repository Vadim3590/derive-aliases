//! Expanding these derive aliases with such a definition:
//!
//! ```ignore
//! Again = Hash, Eq;
//!
//! #[cfg(C)]
//! Bar = #[cfg(C)] Bar, #[cfg(D)] ..Again;
//!
//! Alias = Foo, #[cfg(D)] ..Bar;
//! ```
//!
//! Will give us an `FlatAliasMap` like this:
//!
//! ```ignore
//! FlatAliasMap {
//!     Again => Hash, Eq;
//!     Bar => #[cfg(all(C, C))] Bar, #[cfg(all(C, D))] Hash, #[cfg(all(C, D))] Eq
//!                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//!                                   expansion of ..Again
//!     Alias => Foo, #[cfg(all(D, C, C))] Bar, #[cfg(all(D, C, D))] Hash, #[cfg(all(D, C, D))] Eq
//!                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//!                   expansion of ..Bar
//!                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//!                                          expansion of ..Again
//! }
//! ```
//!
//! Which we then turn into an `AliasMap` by sorting, de-duplicating and grouping all CFGs with the appropriate derives
//!
//! ```ignore
//! AliasMap {
//!     Again => DerivesGroupedByCfgs {
//!         #[cfg(all())] => Hash, Eq
//!     };
//!     Bar => DerivesGroupedByCfgs {
//!         // removed duplicate 'C' in the same
//!         #[cfg(C)] => Bar
//!         // put 2 equivalent derives into the same bucket
//!         #[cfg(all(C, D))] => Hash, Eq
//!     }
//!     Alias =>. DerivesGroupedByCfgs {
//!         #[cfg(all())] => Foo
//!         // removed duplicate "C, C" => "C"
//!         #[cfg(all(D, C))] => Bar
//!         #[cfg(all(D, C, D))] => Hash, Eq
//!     }
//! }
//! ```
//!
//! Which then generates the following code, if we apply `#[derive(..Alias)]`:
//!
//! ```ignore
//! #[std::derive(Foo)]
//! #[cfg_attr(all(D, C), std::derive(Bar))]
//! #[cfg_attr(all(D, C, D), std::derive(Hash, Eq))]
//! ```

use std::io::Write;
use std::sync::atomic::{AtomicI32, AtomicU32};
use std::{
    collections::HashMap,
    fs::{self, File},
    io::{BufReader, BufWriter, Read},
    iter,
    path::{Path, PathBuf},
    sync::{Arc, LazyLock},
};

use crate::{
    dsl::{self, render_error, Alias, AliasDeclaration, ParseError, Stmt},
    format_list, most_similar_alias,
};

type DerivesGroupedByCfgs = HashMap<Vec<dsl::Cfg>, Vec<dsl::Derive>>;
type FlatAliasMap = HashMap<dsl::Alias, Vec<(Vec<dsl::Cfg>, dsl::Derive)>>;
pub type AliasMap = HashMap<dsl::Alias, DerivesGroupedByCfgs>;
type Errors = Vec<String>;

const DOC_FILE: &str = "derive_aliases_doc.rs";

macro_rules! writeln {
    ($($tt:tt)*) => {
        std::writeln!($($tt)*).expect("won't happen")
    };
}

/// Map from `Alias => Vec<Derive>`, where `Alias` expands to a bunch of derive macros (represented as plain strings).
///
/// We don't store the `TokenTree`s directly because they are `!Sync`
pub static ALIAS_MAP: LazyLock<(AliasMap, Errors)> = LazyLock::new(|| {
    let Ok(dir) = std::env::var("CARGO_WORKSPACE_DIR") else {
        panic!(concat!(
            "\n\n`CARGO_WORKSPACE_DIR` environment variable must be set, which points to the directory containing the\n",
            "workspace `Cargo.toml`. Since cargo currently doesn't set this variable, in your workspace create `.cargo/config.toml` with contents:\n",
            "\n",
            "[env]\n",
            "CARGO_WORKSPACE_DIR = {{ value = \"\", relative = true }}\n",
        ));
    };

    let cargo_manifest_dir = Path::new(&dir);

    let file_derive_aliases = cargo_manifest_dir.join("derive_aliases.rs");

    let content = match fs::read_to_string(&file_derive_aliases) {
        Ok(content) => content,
        Err(err) => {
            panic!(
                concat!(
                    "expected {} to exist and contain derive aliases. error: {}.\nhere's an ",
                    "example of syntax in `derive_aliases.rs` file:\n\n{}\n"
                ),
                file_derive_aliases.display(),
                err,
                dsl::EXAMPLE
            );
        }
    };

    let doc_file_path = std::path::Path::new(&dir).join("src").join(DOC_FILE);

    const FIRST_LINE: &str =
        "//! Documentation for Derive Aliases @generated by the `derive_aliases` crate";

    // First, let's guarantee that we're not overwriting the user's file - by checking that we were the ones that created this file
    if let Ok(file) = File::open(&doc_file_path) {
        let mut reader = BufReader::new(file);
        let mut line = String::new();
        let mut first_line_buf = [0; FIRST_LINE.len()];
        reader.read_exact(&mut first_line_buf);

        if first_line_buf == FIRST_LINE.as_bytes() {
            // The file did exist, and we were the ones who created it.
            // Let's overwrite it with empty so we can re-generate all documentation aliases which may have changed
            // since the last compilation
            if let Err(err) = File::create(&doc_file_path) {
                panic!("failed to create {}, which would contain documentation about derive aliases: {err}", doc_file_path.display());
            }
        } else {
            // This file already existed, BUT its first line was not the same as our marker line.
            //
            // That means it is the user's file, and overwriting it could make them really unhappy! Let's not do that.
            panic!(
                concat!(
                    "we were going to write to `{}` to document ",
                    "Derive Aliases for the `derive_aliases` ",
                    "crate, but this file wasn't created by us. Please rename or remove it"
                ),
                file_derive_aliases.display()
            );
        }
    }

    let mut file_derive_aliases_doc = std::fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(&doc_file_path)
        .unwrap_or_else(|err| {
            panic!(
                "failed to open file {} which would document derive aliases: {err}",
                doc_file_path.display()
            )
        });

    let mut w = BufWriter::new(file_derive_aliases_doc);

    let (alias_map, errors) = generate_alias_map(&content, Arc::new(file_derive_aliases));

    // Module documentation
    writeln!(
        w,
        "\
{FIRST_LINE}
//! 
//! Derive aliases are defined in `derive_aliases.rs`
#![allow(warnings)]
#![doc(hidden)]",
    );

    // We want our data structure but sorted:
    //
    // - When re-arranging aliases in the `derive_aliases.rs` file
    //   we don't want to be forced to write the `derive_aliases_doc.rs` file again.
    // - If we don't do this, each compilation session will write the file again and again
    //   with a different order
    let mut alias_map_sorted = alias_map.iter().collect::<Vec<_>>();
    alias_map_sorted
        .sort_unstable_by(|(alias_1, _), (alias_2, _)| alias_1.0.name.cmp(&alias_2.0.name));

    for (alias, derives) in &alias_map_sorted {
        writeln!(
            w,
            "\n/// Derive alias `..{}` expands to the following derives:\n///",
            alias.0.name
        );

        // Write all the documentation for this derive alias
        for (cfgs, derive) in derives
            .iter()
            .flat_map(|(cfgs, derives)| derives.iter().map(move |derive| (cfgs, derive)))
        {
            writeln!(w, "{}", single_line_of_doc_comment_for_derive(cfgs, derive));
        }

        // The actual dummy value we use only to attach documentation to it
        writeln!(w, "pub trait {} {{}}", alias.0.name);
    }

    w.flush().unwrap_or_else(|err| panic!("failed to write file {}, which would contain documentation about derive aliases: {err}", doc_file_path.display()));

    (alias_map, errors)
});

/// Hovering on aliases shows documentation for them. This function generates 1 line of such documentation
///
/// This is the function that generates documentation
/// for a **single** derive that comes from the expansion of an alias.
/// The `cfgs` are the cumulative `cfg` predicates that will be rendered, if non-empty.
///
/// ```rs
/// Eq = PartialEq, #[cfg(bar)] Eq;
/// Ord = PartialOrd, Ord, #[cfg(foo)] ..Eq;
/// ```
///
/// When expanding `..Ord`, we will generate *something like* the following documentation
///
/// ```ignore
/// /// - [`PartialOrd`]
/// /// - [`Ord`]
/// /// - [`PartialEq`] when `#[cfg(foo)]`
/// /// - [`Eq`] when `#[cfg(all(foo, bar))]`
/// ```
///
/// Each bullet point corresponds to a single invocation of this function.
fn single_line_of_doc_comment_for_derive(cfgs: &[dsl::Cfg], derive: &dsl::Derive) -> String {
    let mut doc_line = format!("/// - [`{derive}`]");

    if cfgs.len() == 1 {
        // `#` will also render `#[cfg(...)]` attribute wrapper
        doc_line.push_str(&format!(" when `{doc_line:#}`"));
    } else if cfgs.len() > 2 {
        doc_line.push_str(" when ");
        doc_line.push_str("`#[cfg(all(");
        for (i, cfg) in cfgs.iter().enumerate() {
            // This renders a predicate, e.g. `feature = "serde"`
            doc_line.push_str(&cfg.to_string());

            let is_last = i + 1 == cfgs.len();

            if !is_last {
                // Intersperse all CFG predicates with commas, except the last one
                //
                // cfg, cfg2, cfg3
                //    ^^    ^^
                doc_line.push_str(", ");
            }
        }
        doc_line.push_str("))]`");
    }

    doc_line
}

/// Create the `AliasMap`
///
/// Separate function for use in tests
fn generate_alias_map(content: &str, path: Arc<PathBuf>) -> (AliasMap, Errors) {
    // Recursive map of `Alias => (..Alias OR Derive)`, where `Derive` is a "leaf" but an `..Alias` can
    // be expanded into a list of (..Alias OR Derive)
    let (nested_alias_map, mut errors) = parse(&content, &path.as_ref());

    // Let's resolve the map so each alias maps exactly to a list of derives

    // When we first parse all of the files, we have a deep nested, recursive tree of aliases to (aliases or derives)
    //
    // We want to resolve this tree recursively, so we essentially have a nice, flat map of
    //
    // Alias => Vec<Derive>
    //
    // Where none of the `Derive`s are aliases themselves.
    //
    // In order to do this, we iterate over all of the aliases and inline all RHS recursively until we can't
    // expand any of the `..Alias`ses anymore
    //
    // Additionally, we keep track of all `#[cfg]`s and add them to a `Vec<Cfg>`, so we end up storing
    // (Vec<Cfg>, Derive) as all of the `Cfg`s are additive
    let mut flat_alias_map = FlatAliasMap::new();

    // B = #[cfg(B)] D
    // A = #[cfg(A)] C #[cfg(A, B)] D

    for (_, alias_decl) in &nested_alias_map {
        let mut current_cfg_stack = vec![];
        let mut derives = vec![];

        // We keep a stack of aliases as we expand them, for better error messages
        let mut alias_stack = vec![];

        resolve_derives_for_alias(
            alias_decl,
            &nested_alias_map,
            &mut current_cfg_stack,
            &mut derives,
            &mut errors,
            path.clone(),
            content.as_ref(),
            &mut alias_stack,
        );

        flat_alias_map.insert(alias_decl.alias.clone(), derives);
    }

    // Now that we've got a flat map, it's not yet optimized for efficiency. Every `Derive` is associated with
    // multiple CFGs, and if we generated tokens as-is, we would be outputting an entire `#[cfg_attr]` for every single derive macro!
    //
    // Lets make a `Map<Cfgs => Derives>` that allows us to pick similar CFGs and put them all under a single `#[cfg_attr]`.
    // We want to try and group similar CFGs. E.g., group features `A, A, B` and `B, A, B` under a single `A, B` via sort-then-dedup
    //
    // This won't catch everything. For example, we can still have `#[cfg(all(feature = "serde", feature = "arbitrary"))]`
    // and `#[cfg(all(feature = "arbitrary", feature = "serde"))]` on the same item, which will put them into 2 different buckets.
    //
    // There's nothing we can do about this, because we don't parset the `cfg` expressions to find out what their meaning is semantically,
    // and I don't believe there would be any benefit at all in doing this, if not things getting even worse in terms of compile speeds

    let mut alias_to_grouped_derives = AliasMap::new();

    for (alias, derives) in flat_alias_map {
        // Group derives under similar CFGs
        let mut grouped_derives = DerivesGroupedByCfgs::new();

        for (mut cfgs, derive) in derives {
            // Let's sort all of our cfgs, then de-duplicating will be faster
            //
            // Also we know that `#[cfg(all(B, A))]` and `#[cfg(all(A, B))]` are the same, so we want to sort in order to
            // have both of those have the same hash
            cfgs.sort();

            // Now that we've sorted the above, we'll have this:
            //
            // `#[cfg(all(A, B))]` and `#[cfg(all(A, B))]`
            //
            // Let's remove duplicate CFGs to reduce how many tokens each invocation of `#[derive]` needs to output yet again
            cfgs.dedup();

            grouped_derives
                .entry(cfgs)
                .or_insert_with(Vec::new)
                .push(derive);
        }

        alias_to_grouped_derives.insert(alias, grouped_derives);
    }

    (alias_to_grouped_derives, errors)
}

fn resolve_derives_for_alias(
    // current alias
    alias_decl: &dsl::AliasDeclaration,
    // all aliases and their derives
    alias_map: &HashMap<dsl::Alias, dsl::AliasDeclaration>,
    mut current_cfg_stack: &mut Vec<dsl::Cfg>,
    // derives for the current alias
    derives: &mut Vec<(Vec<dsl::Cfg>, dsl::Derive)>,
    errors: &mut Errors,
    file: Arc<PathBuf>,
    source: &str,
    alias_stack: &mut Vec<dsl::Alias>,
) {
    current_cfg_stack.extend(alias_decl.cfg.clone());
    // Iterate over all aliased items for this alias
    //
    // Alias = Foo, Bar, ..Baz  .next()
    //         ^^^              .next()
    //              ^^^         .next()
    //                   ^^^^^
    for aliased in iter::once(&alias_decl.aliased.first)
        .chain(alias_decl.aliased.items.iter().map(|(_, item)| item))
    {
        // We maintain a stack of `cfgs` which get progressively larger as we expand more and more aliases
        // This is necessay because all `cfg`s are additive
        current_cfg_stack.extend(aliased.cfg.clone());

        match &aliased.item {
            // We insert a Derive. It is the "leaf". There is nothing else to expand.
            dsl::AliasedItem::Derive(derive) => {
                derives.push((current_cfg_stack.clone(), derive.clone()));
            }
            // An alias expansion. like `..Alias`. Expand by recursing 1 layer deeper, with a new layer of CFGs
            dsl::AliasedItem::AliasExpansion(alias_expansion) => {
                // alias_stack.push(alias_expansion.alias.clone());
                if alias_expansion.alias == alias_decl.alias {
                    let alias_stack_formatted = alias_stack
                        .iter()
                        .rev()
                        .map(|alias| format!("- {}", alias.0.name))
                        .collect::<String>();

                    // ERROR: Alias recursion
                    errors.push(dsl::render_error(
                        &dsl::ParseError {
                            span: alias_decl.span.clone(),
                            message: format!(
                                "you cannot use an alias `..{}` inside of itself, that would lead to infinite recursion!\n\nstack of aliases:\n\n{alias_stack_formatted}",
                                alias_decl.alias.0.name
                            ),
                        },
                        file.clone(),
                        &source,
                    ));
                    continue;
                }

                let Some(deeper_alias_decl) = alias_map.get(&alias_expansion.alias) else {
                    let alias_stack_formatted = alias_stack
                        .iter()
                        .rev()
                        .map(|alias| format!("- {}", alias.0.name))
                        .collect::<String>();

                    // ERROR: Alias not found.
                    errors.push(dsl::render_error(
                        &dsl::ParseError {
                            span: alias_decl.span.clone(),
                            message: format!(
                                "alias `{}` is undefined!\n\n{}available aliases: {}\n\nstack of aliases:\n\n{alias_stack_formatted}",
                                alias_expansion.alias.0.name,
                                most_similar_alias(&alias_expansion.alias.0.name)
                                    .map(|f| format!("help: did you mean: {f}\n\n"))
                                    .unwrap_or_default(),
                                format_list(alias_map.iter().map(|(a, _)| &a.0.name))
                            ),
                        },
                        file.clone(),
                        &source,
                    ));
                    continue;
                };

                resolve_derives_for_alias(
                    deeper_alias_decl,
                    alias_map,
                    current_cfg_stack,
                    derives,
                    errors,
                    file.clone(),
                    source,
                    alias_stack,
                );
            }
        }
    }
}

/// Parse derive aliases file at `path` with `content`, and returns the result with all paths resolved.
/// The `Vec<String>` return is all parse errors encountered whilst parsing.
pub fn parse(content: &str, path: &Path) -> (HashMap<Alias, AliasDeclaration>, Vec<String>) {
    fn inner(
        content: &str,
        path: impl AsRef<Path>,
        alias_declarations: &mut HashMap<Alias, AliasDeclaration>,
        errors: &mut Vec<String>,
    ) {
        let file = dsl::parse_single_file(&content, path);

        // Add all of the syntax errors
        errors.extend(
            file.errors
                .iter()
                .map(|error| render_error(&error, file.span.file.clone(), content)),
        );

        for stmt in file.stmts {
            match stmt {
                Stmt::AliasDeclaration(alias_declaration) => {
                    alias_declarations.insert(alias_declaration.alias.clone(), alias_declaration);
                }
                Stmt::Import(import) => {
                    match std::fs::read_to_string(&*import.path) {
                        Ok(file) => inner(&file, &*import.path, alias_declarations, errors),
                        Err(err) => {
                            errors.push(render_error(
                                &ParseError {
                                    span: import.span,
                                    message: format!(
                                        "failed to read file at {}: {err}",
                                        import.path.display()
                                    ),
                                },
                                file.span.file.clone(),
                                content,
                            ));
                            continue;
                        }
                    };
                }
            }
        }
    }

    let mut errors = vec![];
    let mut alias_declarations = HashMap::new();

    // we need to return a MAP here

    inner(content, path, &mut alias_declarations, &mut errors);

    (alias_declarations, errors)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dsl::{self, Alias, Cfg, Derive, Ident, Span};
    use std::{collections::HashMap, path::PathBuf, sync::Arc};

    fn generate_alias_map(content: &str) -> (AliasMap, Errors) {
        super::generate_alias_map(content, Arc::new("derive_aliases.rs".into()))
    }

    #[test]
    fn generate_alias_map_basic_expansion() {
        let content = stringify!(
            A = B, C;
            MyAlias = D, ..A;
        );

        let (alias_map, errors) = generate_alias_map(content);

        assert!(errors.is_empty());
        assert_eq!(alias_map.len(), 2);

        // Check A's group
        let a_derives = &alias_map[&Alias(Ident {
            name: "A".to_string(),
            span: dummy::span(),
        })];
        assert_eq!(a_derives.len(), 1);
        let (cfgs, derives) = a_derives.iter().next().unwrap();
        assert!(cfgs.is_empty());
        assert_eq!(derives.len(), 2);
        assert_eq!(derives[0].components.first.name, "B");
        assert_eq!(derives[1].components.first.name, "C");

        // Check MyAlias's group
        let my_alias_derives = &alias_map[&Alias(Ident {
            name: "MyAlias".to_string(),
            span: dummy::span(),
        })];
        assert_eq!(my_alias_derives.len(), 1);
        let (cfgs, derives) = my_alias_derives.iter().next().unwrap();
        assert!(cfgs.is_empty());
        assert_eq!(derives.len(), 3);
        assert_eq!(derives[0].components.first.name, "D");
        assert_eq!(derives[1].components.first.name, "B");
        assert_eq!(derives[2].components.first.name, "C");
    }

    #[test]
    fn generate_alias_map_cfg_accumulation() {
        let content = stringify!(
            #[cfg(B)] B = D;
            #[cfg(A)] A = C, ..B;
        );

        let (alias_map, errors) = generate_alias_map(content);

        for e in &errors {
            eprintln!("{e}");
        }

        assert!(errors.is_empty());
        assert_eq!(alias_map.len(), 2);

        // Check A's group, which should contain two derives with different cfg predicates
        let a_derives = &alias_map[&Alias(Ident {
            name: "A".to_string(),
            span: dummy::span(),
        })];

        assert_eq!(a_derives.len(), 2);

        let mut expected_cfgs = HashMap::new();
        expected_cfgs.insert(vec![dummy::cfg("A")], vec![dummy::derive("C")]);
        expected_cfgs.insert(
            vec![dummy::cfg("A"), dummy::cfg("B")],
            vec![dummy::derive("D")],
        );

        for (cfgs, derives) in a_derives {
            let key = cfgs.clone();

            let mut derives_names: Vec<_> = derives
                .iter()
                .map(|d| d.components.first.name.clone())
                .collect();

            derives_names.sort();

            let mut expected_derives_names: Vec<_> = expected_cfgs[&key]
                .iter()
                .map(|d| d.components.first.name.clone())
                .collect();
            expected_derives_names.sort();

            assert_eq!(derives_names, expected_derives_names);
        }
    }

    #[test]
    fn alias_not_found_error() {
        let content = stringify!(MyAlias = ..MissingAlias;);
        let (_alias_map, errors) = generate_alias_map(content);

        assert_eq!(errors.len(), 1);
        assert!(errors[0].contains("alias `MissingAlias` is undefined!"));
    }

    // create dummy data
    mod dummy {
        use super::*;

        pub fn span() -> Span {
            Span {
                location: 0..0,
                file: Arc::new(PathBuf::from("derive_aliases.rs")),
            }
        }

        pub fn cfg(content: &str) -> Cfg {
            Cfg {
                span: span(),
                keyword: dsl::token::Cfg(span()),
                cfg: content.to_string(),
            }
        }

        pub fn derive(name: &str) -> Derive {
            Derive {
                span: dummy::span(),
                leading_colon: None,
                components: dsl::Separated {
                    first: Ident {
                        name: name.to_string(),
                        span: dummy::span(),
                    },
                    items: Vec::new(),
                },
            }
        }

        pub fn alias_decl(
            name: &str,
            items: Vec<(Option<Cfg>, dsl::AliasedItem)>,
        ) -> dsl::AliasDeclaration {
            let (first_cfg, first_item) = items.clone().into_iter().next().unwrap();
            let mut separated_items = Vec::new();

            for (cfg, item) in items.into_iter().skip(1) {
                separated_items.push((
                    dsl::token::Comma(dummy::span()),
                    dsl::Aliased {
                        span: dummy::span(),
                        cfg,
                        item,
                    },
                ));
            }

            dsl::AliasDeclaration {
                span: dummy::span(),
                cfg: None,
                alias: Alias(Ident {
                    name: name.to_string(),
                    span: dummy::span(),
                }),
                eq_token: dsl::token::Eq(dummy::span()),
                aliased: dsl::Separated {
                    first: dsl::Aliased {
                        span: dummy::span(),
                        cfg: first_cfg,
                        item: first_item,
                    },
                    items: separated_items,
                },
                trailing_comma: None,
            }
        }
    }
}
